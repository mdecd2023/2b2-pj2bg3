var tipuesearch = {"pages": [{'title': 'About', 'text': '41023211 Wmrtbij49h  fork \n 41023239 a92826 \n 41023249 BrianTsai071 \n 41023252 ZYC0923 \n github repository: https://github.com/mdecd2023/2b2-pj2bg3 \xa0 \n github page: https://mdecd2023.github.io/2b2-pj2bg3 \n \n', 'tags': '', 'url': 'About.html'}, {'title': 'Brython', 'text': 'https://en.wikipedia.org/wiki/Python_(programming_language) \n Examples: \n https://gist.github.com/mdecycu/d9082d678096bd58378d6afe2c7fa05d \n https://www.geeksforgeeks.org/python-programming-examples/ \n https://www.programiz.com/python-programming/examples \n https://www.freecodecamp.org/news/python-code-examples-sample-script-coding-tutorial-for-beginners/ \n Python Tutorial: \n https://docs.python.org/3/tutorial/ \n An informal introduction to Python \n Indentation (Python 採 4 個 Spaces 縮排, 以界定執行範圍) \n Variables ( Python Keywords ) \n Comments (# 單行註解, 三個單引號或三個雙引號標註多行註解) \n Numbers  (整數 int(), 浮點數 float()) \n Strings  (字串) \n print (Python 內建函式,  print()  函式) \n Python control flow tools \n for \n if \n range \n open \n read \n lists \n tuples \n dictionaries \n functions \n try ... except \n break \n pass \n classes \n 這個頁面 demo 如何在同一頁面下納入多個線上 Ace 編輯器與執行按鈕 ( practice_html.txt  動態頁面超文件). \n practice_html.txt  動態頁面超文件應該可以在啟動 Brython 時, 設定將 .py 檔案放入 downloads/py 目錄中引用. \n 亦即將所有對應的 html 也使用 Brython 產生, 然後寫為  class  後, 在範例導入時透過  instance  引用. \n <!-- 啟動 Brython -->\n<script>\nwindow.onload=function(){\nbrython({debug:1, pythonpath:[\'./../cmsimde/static/\',\'./../downloads/py/\']});\n}\n</script> \n 從 1 累加到 100: \n 1 add to 100 \n 將 iterable 與 iterator  相關說明 , 利用 Brython 與 Ace Editor 整理在這個頁面. \n  導入 brython 程式庫  \n \n \n \n \n  啟動 Brython  \n \n \n \n  導入 FileSaver 與 filereader  \n \n \n \n \n  導入 ace  \n \n \n \n \n \n \n  導入 gearUtils-0.9.js Cango 齒輪繪圖程式庫  \n \n \n \n \n \n \n  請注意, 這裡使用 Javascript 將 localStorage["kw_py_src1"] 中存在近端瀏覽器的程式碼, 由使用者決定存檔名稱 \n \n \n \n \n \n \n  add 1 to 100 開始  \n \n \n  add 1 to 100 結束 \n  editor1 開始  \n  用來顯示程式碼的 editor 區域  \n \n  以下的表單與按鈕與前面的 Javascript doSave 函式以及 FileSaver.min.js 互相配合  \n  存擋表單開始  \n Filename:  .py   \n  存擋表單結束  \n \n  執行與清除按鈕開始  \n Run   Output   清除輸出區 清除繪圖區 Reload \n  執行與清除按鈕結束  \n \n  程式執行 ouput 區  \n \n  Brython 程式執行的結果, 都以 brython_div1 作為切入位置  \n \n  editor1 結束   ##########################################  \n 從 1 累加到 100 part2: \n 1 add to 100 cango_three_gears BSnake AI Tetris Rotating Block \n  請注意, 這裡使用 Javascript 將 localStorage["kw_py_src2"] 中存在近端瀏覽器的程式碼, 由使用者決定存檔名稱 \n \n \n \n  add 1 to 100 part2 開始  \n \n \n  add 1 to 100 part2 結束 \n  editor2 開始  \n  用來顯示程式碼的 editor 區域  \n \n  以下的表單與按鈕與前面的 Javascript doSave 函式以及 FileSaver.min.js 互相配合  \n  存擋表單開始  \n Filename:  .py   \n  存擋表單結束  \n \n  執行與清除按鈕開始  \n Run   Output   清除輸出區 清除繪圖區 Reload \n  執行與清除按鈕結束  \n \n  程式執行 ouput 區  \n \n  Brython 程式執行的結果, 都以 brython_div1 作為切入位置  \n \n  editor2 結束  \n \n \n \n', 'tags': '', 'url': 'Brython.html'}, {'title': 'Brython_ex2', 'text': 'This code uses the Euler method to approximate the solution to the ODE dy/dx = x - y with an initial condition of y0 = 1.0. The solution is calculated for a range of x values from 0 to 5. \n \n \n \n \n \n \n Solve ODE: \n from browser import document\n\ndef dy_dx(y, x):\n    return x - y\n\nx_start = 0\nx_end = 5\nn_points = 100\nx = [x_start + i * (x_end - x_start) / (n_points - 1) for i in range(n_points)]\ny0 = 1.0\nh = x[1] - x[0]\ny = [y0]\nfor i in range(1, len(x)):\n    y.append(y[-1] + h * dy_dx(y[-1], x[i-1]))\n\n# Create a new paragraph element and set its text content to the solution\np = document.createElement(\'p\')\np.textContent = f"The solution to the ODE is: {y}"\n\n# Append the paragraph element to the body of the webpage\ndocument.body.appendChild(p) \n \n \n \n \n \n Brython environment and  Plotly.js : \n <script src="./../cmsimde/static/brython.js"></script>\n<script src="./../cmsimde/static/brython_stdlib.js"></script>\n<script>// <![CDATA[\nwindow.onload=function(){\nbrython({debug:1, pythonpath:[\'./../cmsimde/static/\']});\n}\n// ]]></script>\n<p id="brython_div"></p> \n Brython programe with Plotly.js: \n from browser import document, window\n\ndef dy_dx(y, x):\n    return x - y\n\nx_start = 0\nx_end = 5\nn_points = 100\nx = [x_start + i * (x_end - x_start) / (n_points - 1) for i in range(n_points)]\ny0 = 1.0\nh = x[1] - x[0]\ny = [y0]\nfor i in range(1, len(x)):\n    y.append(y[-1] + h * dy_dx(y[-1], x[i-1]))\n\n# Create a new div element to hold the plot\n#plot_div = document.createElement(\'div\')\n#plot_div.id = \'plot\'\n#document.body.appendChild(plot_div)\nplot_div = document["brython_div"]\n\n# Plot the solution using plotly.js\ndata = [{\'x\': x, \'y\': y}]\nwindow.Plotly.newPlot(\'brython_div\', data) \n This code defines a function dy_dx that represents the mass-spring-damper ordinary differential equation. The Euler method is used to solve this equation for a range of x values from 0 to 20 with initial conditions of y0 = [1.0, 0.0]. The solution is then plotted on the webpage using  plotly.js . \n \n \n \n \n This code defines a function dy_dx that represents the mass-spring-damper system with a PID controller. The gains of the PID controller are set to Kp = 10.0, Ki = 1.0, and Kd = 0.5. The Euler method is used to solve this system of equations for a range of x values from 0 to 20 with initial conditions of y0 = [0.0, 0.0, 0.0, 0.0]. The response of the system is then plotted on the webpage using  plotly.js . \n \n \n \n \n \n \n \n \n \n \n \n \n \n STL part viewer \n \n \n \n \n Using  sine-cosine algorithm  to optimize with constraints in Brython: \n <!DOCTYPE html>\n<html>\n<head>\n    <script type="text/javascript" src="https://cdn.jsdelivr.net/npm/brython@3/dist/brython_stdlib"></script>\n</head>\n<body onload="brython()">\n\n<div id="output"></div>\n\n<script type="text/python">\nfrom browser import document\nfrom random import random, uniform\nfrom math import sin, cos, pi\n\n# Define the objective function\ndef objective_function(x):\n    return x[0]**2 + x[1]**2\n\n# Define the constraint functions\ndef constraint1(x):\n    return x[0] + x[1] - 2\n\ndef constraint2(x):\n    return 1 - x[0] - x[1]\n\n# Define the penalty function\ndef penalty_function(x):\n    penalty = 0\n    if constraint1(x) > 0:\n        penalty += constraint1(x)\n    if constraint2(x) > 0:\n        penalty += constraint2(x)\n    return penalty\n\n# Define the fitness function\ndef fitness_function(x):\n    return objective_function(x) + penalty_function(x)\n\n# Define the sine cosine algorithm\ndef sine_cosine_algorithm(fitness_function, dimension, lower_bound, upper_bound, population_size, max_iterations):\n    # Initialize the population\n    population = [[uniform(lower_bound, upper_bound) for _ in range(dimension)] for _ in range(population_size)]\n    population_fitness = [fitness_function(individual) for individual in population]\n\n    # Initialize the best solution\n    best_solution = population[0]\n    best_fitness = population_fitness[0]\n\n    # Main loop of the algorithm\n    for iteration in range(max_iterations):\n        # Calculate the value of a and r1\n        a = 2 - iteration * (2 / max_iterations)\n        r1 = 2 * pi * random()\n\n        # Update the population\n        for i in range(population_size):\n            # Calculate the value of r2, r3 and r4\n            r2 = 2 * random()\n            r3 = 2 * random()\n            r4 = random()\n\n            # Update the individual\n            for j in range(dimension):\n                if r4 < 0.5:\n                    population[i][j] += r1 * sin(r2) * abs(r3 * best_solution[j] - population[i][j])\n                else:\n                    population[i][j] += r1 * cos(r2) * abs(r3 * best_solution[j] - population[i][j])\n\n                # Make sure the individual is within the bounds\n                if population[i][j] < lower_bound:\n                    population[i][j] = lower_bound\n                elif population[i][j] > upper_bound:\n                    population[i][j] = upper_bound\n\n            # Calculate the fitness of the individual\n            population_fitness[i] = fitness_function(population[i])\n\n            # Update the best solution\n            if population_fitness[i] < best_fitness:\n                best_solution = population[i]\n                best_fitness = population_fitness[i]\n\n        # Print the current iteration and best fitness\n        print(f\'Iteration: {iteration + 1}, Best Fitness: {best_fitness:.6f}\')\n\n    return best_solution\n\n# Run the sine cosine algorithm to solve the optimization problem with constraints\nbest_solution = sine_cosine_algorithm(fitness_function, dimension=2, lower_bound=-10, upper_bound=10, population_size=50, max_iterations=100)\n\n# Print the result\noutput_div = document[\'output\']\noutput_div.text = f\'Best Solution: {best_solution}\'\n</script>\n\n<script src="https://cdn.jsdelivr.net/npm/brython@3/dist/brython"></script>\n</body>\n</html> \n Plot the result by using  plotly.js : \n <!DOCTYPE html>\n<html>\n<head>\n    <script type="text/javascript" src="https://cdn.jsdelivr.net/npm/brython@3/dist/brython_stdlib"></script>\n    <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>\n</head>\n<body onload="brython()">\n\n<div id="output"></div>\n<div id="plot"></div>\n\n<script type="text/python">\nfrom browser import document\nfrom random import random, uniform\nfrom math import sin, cos, pi\n\n# Define the objective function\ndef objective_function(x):\n    return x[0]**2 + x[1]**2\n\n# Define the constraint functions\ndef constraint1(x):\n    return x[0] + x[1] - 2\n\ndef constraint2(x):\n    return 1 - x[0] - x[1]\n\n# Define the penalty function\ndef penalty_function(x):\n    penalty = 0\n    if constraint1(x) > 0:\n        penalty += constraint1(x)\n    if constraint2(x) > 0:\n        penalty += constraint2(x)\n    return penalty\n\n# Define the fitness function\ndef fitness_function(x):\n    return objective_function(x) + penalty_function(x)\n\n# Define the sine cosine algorithm\ndef sine_cosine_algorithm(fitness_function, dimension, lower_bound, upper_bound, population_size, max_iterations):\n    # Initialize the population\n    population = [[uniform(lower_bound, upper_bound) for _ in range(dimension)] for _ in range(population_size)]\n    population_fitness = [fitness_function(individual) for individual in population]\n\n    # Initialize the best solution\n    best_solution = population[0]\n    best_fitness = population_fitness[0]\n\n    # Main loop of the algorithm\n    for iteration in range(max_iterations):\n        # Calculate the value of a and r1\n        a = 2 - iteration * (2 / max_iterations)\n        r1 = 2 * pi * random()\n\n        # Update the population\n        for i in range(population_size):\n            # Calculate the value of r2, r3 and r4\n            r2 = 2 * random()\n            r3 = 2 * random()\n            r4 = random()\n\n            # Update the individual\n            for j in range(dimension):\n                if r4 < 0.5:\n                    population[i][j] += r1 * sin(r2) * abs(r3 * best_solution[j] - population[i][j])\n                else:\n                    population[i][j] += r1 * cos(r2) * abs(r3 * best_solution[j] - population[i][j])\n\n                # Make sure the individual is within the bounds\n                if population[i][j] < lower_bound:\n                    population[i][j] = lower_bound\n                elif population[i][j] > upper_bound:\n                    population[i][j] = upper_bound\n\n            # Calculate the fitness of the individual\n            population_fitness[i] = fitness_function(population[i])\n\n            # Update the best solution\n            if population_fitness[i] < best_fitness:\n                best_solution = population[i]\n                best_fitness = population_fitness[i]\n\n        # Print the current iteration and best fitness\n        print(f\'Iteration: {iteration + 1}, Best Fitness: {best_fitness:.6f}\')\n\n    return best_solution\n\n# Run the sine cosine algorithm to solve the optimization problem with constraints\nbest_solution = sine_cosine_algorithm(fitness_function, dimension=2, lower_bound=-10, upper_bound=10, population_size=50, max_iterations=100)\n\n# Print the result\noutput_div = document[\'output\']\noutput_div.text = f\'Best Solution: {best_solution}\'\n\n# Plot the result using Plotly.js\ndata = [\n    {\n        \'x\': [best_solution[0]],\n        \'y\': [best_solution[1]],\n        \'mode\': \'markers\',\n        \'marker\': {\'size\': 12},\n        \'name\': \'Best Solution\'\n    }\n]\n\nlayout = {\n    \'xaxis\': {\'range\': [-10, 10]},\n    \'yaxis\': {\'range\': [-10, 10]},\n}\n\nPlotly.newPlot(\'plot\', data, layout)\n</script>\n\n<script src="https://cdn.jsdelivr.net/npm/brython@3/dist/brython"></script>\n</body>\n</html> \n \n', 'tags': '', 'url': 'Brython_ex2.html'}, {'title': 'w9', 'text': '', 'tags': '', 'url': 'w9.html'}, {'title': '41023211-1', 'text': '自評60 \n 心得:謝謝組員幫忙，不會地問我的組員他們也很願意幫忙 \n \n', 'tags': '', 'url': '41023211-1.html'}, {'title': '41023239-1', 'text': '心得:謝謝老師在這堂課教會我原來CoppeliaSim還可以這樣控制機器人，希望可以在教授的教導下學到更多有關控制方面的技能。 \n', 'tags': '', 'url': '41023239-1.html'}, {'title': '41023249-1', 'text': '心得:在這學期學到了如何用CoppeliaSim控制機器人，但還不是很熟，所以還要更努力 \n \n', 'tags': '', 'url': '41023249-1.html'}, {'title': '41023252-1', 'text': '4/20心得: \n 今天把zmqRemoteAPI透過23000port控制機器人的實習內容做出，機器人在操作上還是有些不靈活，雖然有遇到一些問題但還是克服了，且在今天也把pj2的網頁建出來。 \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \xa0  Link back to Colorlib can\'t be removed. Template is licensed under CC BY 3.0.  \n  程式執行 ouput 區  \n \n  執行與清除按鈕結束  \n Run   Output   清除輸出區 清除繪圖區 Reload \n  執行與清除按鈕開始  \n \n  存擋表單結束  \n  存擋表單開始  \n  以下的表單與按鈕與前面的 Javascript doSave 函式以及 FileSaver.min.js 互相配合  \n  用來顯示程式碼的 editor 區域  \n  add 1 to 100 結束 \n \n  add 1 to 100 開始  \n \n \n \n \n \n \n \n \n \n \n  請注意, 這裡使用 Javascript 將 localStorage["kw_py_src1"] 中存在近端瀏覽器的程式碼, 由使用者決定存檔名稱 \n \n \n \n \n \n  導入 gearUtils-0.9.js Cango 齒輪繪圖程式庫  \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n  導入 ace  \n \n \n \n \n \n \n  導入 FileSaver 與 filereader  \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n pj2bg13 \n', 'tags': '', 'url': '41023252-1.html'}, {'title': 'w10', 'text': '1.What is zmqRemoteAPI, and how does it relate to CoppeliaSim? \n A: zmqRemoteAPI  是由Coppelia Robotics 開發的遠端應用程式編程介面（API），用於其機器人仿真軟體CoppeliaSim。它是一種輕量級且靈活的協議，允許使用各種編程語言編寫的外部程式控制和與CoppeliaSim進行交互。 \n 2.How do you establish a connection between a Python script and CoppeliaSim using zmqRemoteAPI? \n A:要使用zmqRemoteAPI在Python腳本和CoppeliaSim之間建立連接，可以按照以下步驟操作： 1.確保已經安裝了zmqRemoteAPI庫並在Python腳本中進行了導入。可以使用以下命令安裝該庫： pip install zmq 在腳本中導入zmqRemoteAPI： import  sim \n 2.在CoppeliaSim中啟用遠程API。在CoppeliaSim中，選擇“File”菜單中的“Open scene”， 打開需要使用遠程API的場景文件。 然後，選擇“Edit”菜單中的“Remote API”，並確保選中“Enable the remote API server”覆選框。 3.在Python腳本中連接到CoppeliaSim。在Python腳本中，使用以下代碼行連接到CoppeliaSim： sim.simxFinish(- 1 )  #關閉任何現有的連接 \nclientID = sim.simxStart( \'127.0.0.1\' , 19997 , True , True , 5000 , 5 )  #連接到CoppeliaSim 這將關閉任何現有的連接並連接到IP地址為\'127.0.0.1\'，端口號為19997的CoppeliaSim實例。 最後一個參數是連接超時時間，以毫秒為單位。 4.檢查連接狀態。可以使用以下代碼檢查連接狀態： if clientID!=-1: \xa0\xa0\xa0 print (\'連接成功\') else: \xa0\xa0\xa0 print (\'連接失敗\') \xa0\xa0\xa0 sys.exit(\'無法連接到CoppeliaSim\') 如果連接成功，將輸出“連接成功”。如果連接失敗，將輸出“連接失敗”，並退出Python腳本。 5.在Python腳本中使用遠程API。 現在，可以使用zmqRemoteAPI在Python腳本和CoppeliaSim之間發送命令和數據。 例如，可以使用以下代碼獲取CoppeliaSim中一個對象的句柄： res, handle = sim. simxGetObjectHandle (clientID, \'objectName\' ,sim.simx_opmode_blocking) 這將使用遠程API獲取名為\'objectName\'的對象的句柄，並將其存儲在變量“handle”中。 希望這些步驟可以幫助你使用zmqRemoteAPI在Python腳本和CoppeliaSim之間建立連接。 \n CoppeliaSim是一款流行的機器人仿真軟體，它提供了強大的建模和仿真工具，可以幫助使用者在虛擬環境中測試和開發機器人應用程式。而zmqRemoteAPI則提供了一種方便的方式，讓使用者可以透過編程語言調用CoppeliaSim中的各種功能和服務，從而實現更高級別的仿真控制和自動化。 \n \n 3.What are some common use cases for zmqRemoteAPI in CoppeliaSim? \n A:zmqRemoteAPI 是 CoppeliaSim 中使用的輕量級通訊協議，常見的使用案例包括： \n \n \n 遠程控制機器人：使用 zmqRemoteAPI 可以通過網絡將機器人的運動指令發送到 CoppeliaSim 模擬環境中，以控制機器人的運動，從而進行機器人控制系統的測試和開發。 \n \n \n 數據收集和分析：使用 zmqRemoteAPI 可以在 CoppeliaSim 中收集機器人的感測器數據，並將其傳送到外部數據處理軟件中進行進一步的分析和處理，以提高機器人系統的性能和效率。 \n \n \n 多機協同：使用 zmqRemoteAPI 可以實現多個 CoppeliaSim 實例之間的通訊和協同，以便在不同的機器上進行機器人系統的協同開發和測試。 \n \n \n 遠程遙測和診斷：使用 zmqRemoteAPI 可以將 CoppeliaSim 中的遠程診斷和調試數據傳送到外部診斷軟件中進行分析和處理，以便遠程監測和診斷機器人系統的運行狀態和問題。 \n \n \n \n 亂數 \n  導入 brython 程式庫  \n \n \n \n \n  啟動 Brython  \n \n \n \n  導入 FileSaver 與 filereader  \n \n \n \n \n  導入 ace  \n \n \n \n \n \n \n  導入 gearUtils-0.9.js Cango 齒輪繪圖程式庫  \n \n \n \n \n \n \n  請注意, 這裡使用 Javascript 將 localStorage["kw_py_src1"] 中存在近端瀏覽器的程式碼, 由使用者決定存檔名稱 \n \n \n \n \n \n \n  亂數  \n \n \n  亂數  結束 \n  editor1 開始  \n  用來顯示程式碼的 editor 區域  \n \n  以下的表單與按鈕與前面的 Javascript doSave 函式以及 FileSaver.min.js 互相配合  \n  存擋表單開始  \n Filename:  .py   \n  存擋表單結束  \n \n  執行與清除按鈕開始  \n Run   Output   清除輸出區 清除繪圖區 Reload \n  執行與清除按鈕結束  \n \n  程式執行 ouput 區  \n \n  Brython 程式執行的結果, 都以 brython_div1 作為切入位置  \n \n', 'tags': '', 'url': 'w10.html'}, {'title': 'w11', 'text': '雙球員足球場景連結: 2players \n zmqRemoteAPI Python 操控含場景: zmqRemoteAPI Python 操控含場景.7z \n zmqRemoteAPI Python 操控含場景5月11號改版: \n zmqRemoteAPI Python 操控含場景5.11版.zip \n 場景檔案: 足球場景 \n Onshape足球場景繪製及CoppeliaSim場景匯入影片 \n \n \n \n \n 影片說明:先在Onshape上將足球場景的形狀畫出再將其匯入至CoppeliaSim上測試，然後再回到到Onshape將大小調整至合適尺寸再匯入CoppeliaSim。 \n \n \n CoppeliaSim足球對戰模擬影片 \n \n \n \n \n 影片說明:我們是用onshape做的球場，然後加上之前W9教的可操控機器人，然後使用感測器和記分板的配合在球門上，使得可以進行遊玩計分的動作。並讓進球後可重製球場達到可一直遊玩的目的。 \n \n', 'tags': '', 'url': 'w11.html'}, {'title': '41023211-2', 'text': '', 'tags': '', 'url': '41023211-2.html'}, {'title': '41023239-2', 'text': '心得:這次是使用onshape畫出足球場後，放入四台可操控的玩具車，並使用船管器配合球門加上記分板使得有戲可以進行計分，這次要求記分板不能顯示在螢幕上而是要真實存在於球場上，所以有點困難，但別組的組員都很有耐心地教我，所以進行得很順利。 \n 自評:65 \n', 'tags': '', 'url': '41023239-2.html'}, {'title': '41023249-2', 'text': '', 'tags': '', 'url': '41023249-2.html'}, {'title': '41023252-2', 'text': '心得:在這次作業中的球大小是自行定義，所以當初在Onshape上將尺寸調整數次才得到適合的大小，再來將場景導入後加上傳感器時，為了保證能夠完整感應，在大小及位置上也是耗費了 不少心力，雖然在計分板的設計遇到了不少問題，但是也在同學的建議及幫助下完成了，能夠將整個足球遊戲完成讓我獲益良多。 \n 自評:65 \n \n  editor1 結束   ########################################## ', 'tags': '', 'url': '41023252-2.html'}]};